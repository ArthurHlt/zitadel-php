<?php
/**
 * ZITADELWebKeysApi
 * PHP version 7.2
 *
 * @category Class
 * @package  ArthurHlt\Zitadel
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Management API
 *
 * The management API is as the name states the interface where systems can mutate IAM objects like organizations, projects, clients, users and so on if they have the necessary access rights.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: hi@zitadel.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ArthurHlt\Zitadel\Api;

use GuzzleHttp\Psr7\MultipartStream;
use Http\Client\Common\Plugin\ErrorPlugin;
use Http\Client\Common\Plugin\RedirectPlugin;
use Http\Client\Common\PluginClient;
use Http\Client\Common\PluginClientFactory;
use Http\Client\Exception\HttpException;
use Http\Client\HttpAsyncClient;
use Http\Discovery\HttpAsyncClientDiscovery;
use Http\Discovery\Psr17FactoryDiscovery;
use Http\Discovery\Psr18ClientDiscovery;
use Http\Message\RequestFactory;
use Http\Promise\Promise;
use ArthurHlt\Zitadel\ApiException;
use ArthurHlt\Zitadel\Configuration;
use ArthurHlt\Zitadel\DebugPlugin;
use ArthurHlt\Zitadel\HeaderSelector;
use ArthurHlt\Zitadel\ObjectSerializer;
use Psr\Http\Client\ClientExceptionInterface;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\UriFactoryInterface;
use Psr\Http\Message\UriInterface;
use function sprintf;

/**
 * ZITADELWebKeysApi Class Doc Comment
 *
 * @category Class
 * @package  ArthurHlt\Zitadel
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ZITADELWebKeysApi
{
    /**
     * @var PluginClient
     */
    protected $httpClient;

    /**
     * @var PluginClient
     */
    protected $httpAsyncClient;

    /**
     * @var UriFactoryInterface
     */
    protected $uriFactory;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @var RequestFactoryInterface
     */
    protected $requestFactory;

    /**
     * @var StreamFactoryInterface
     */
    protected $streamFactory;

    public function __construct(
        ?ClientInterface $httpClient = null,
        ?Configuration $config = null,
        ?HttpAsyncClient $httpAsyncClient = null,
        ?UriFactoryInterface $uriFactory = null,
        ?RequestFactoryInterface $requestFactory = null,
        ?StreamFactoryInterface $streamFactory = null,
        ?HeaderSelector $selector = null,
        ?array $plugins = null,
        $hostIndex = 0
    ) {
        $this->config = $config ?? (new Configuration())->setHost('https://zitadel.cloud/management/v1');
        $this->requestFactory = $requestFactory ?? Psr17FactoryDiscovery::findRequestFactory();
        $this->streamFactory = $streamFactory ?? Psr17FactoryDiscovery::findStreamFactory();

        $plugins = $plugins ?? [
            new RedirectPlugin(['strict' => true]),
            new ErrorPlugin(),
        ];

        if ($this->config->getDebug()) {
            $plugins[] = new DebugPlugin(fopen($this->config->getDebugFile(), 'ab'));
        }

        $this->httpClient = (new PluginClientFactory())->createClient(
            $httpClient ?? Psr18ClientDiscovery::find(),
            $plugins
        );

        $this->httpAsyncClient = (new PluginClientFactory())->createClient(
            $httpAsyncClient ?? HttpAsyncClientDiscovery::find(),
            $plugins
        );

        $this->uriFactory = $uriFactory ?? Psr17FactoryDiscovery::findUriFactory();

        $this->headerSelector = $selector ?? new HeaderSelector();

        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation zITADELWebKeysActivateWebKey
     *
     * Activate a signing key for the instance
     *
     * @param  string $id id (required)
     * @param  string $instanceId instanceId (optional)
     * @param  string $instanceDomain instanceDomain (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ArthurHlt\Zitadel\Model\V3alphaActivateWebKeyResponse|\ArthurHlt\Zitadel\Model\RpcStatus
     */
    public function zITADELWebKeysActivateWebKey($id, $instanceId = null, $instanceDomain = null)
    {
        list($response) = $this->zITADELWebKeysActivateWebKeyWithHttpInfo($id, $instanceId, $instanceDomain);
        return $response;
    }

    /**
     * Operation zITADELWebKeysActivateWebKeyWithHttpInfo
     *
     * Activate a signing key for the instance
     *
     * @param  string $id (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ArthurHlt\Zitadel\Model\V3alphaActivateWebKeyResponse|\ArthurHlt\Zitadel\Model\RpcStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function zITADELWebKeysActivateWebKeyWithHttpInfo($id, $instanceId = null, $instanceDomain = null)
    {
        $request = $this->zITADELWebKeysActivateWebKeyRequest($id, $instanceId, $instanceDomain);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();

            switch($statusCode) {
                case 200:
                    if ('\ArthurHlt\Zitadel\Model\V3alphaActivateWebKeyResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\V3alphaActivateWebKeyResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ArthurHlt\Zitadel\Model\RpcStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\RpcStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ArthurHlt\Zitadel\Model\V3alphaActivateWebKeyResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\V3alphaActivateWebKeyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\RpcStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation zITADELWebKeysActivateWebKeyAsync
     *
     * Activate a signing key for the instance
     *
     * @param  string $id (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function zITADELWebKeysActivateWebKeyAsync($id, $instanceId = null, $instanceDomain = null)
    {
        return $this->zITADELWebKeysActivateWebKeyAsyncWithHttpInfo($id, $instanceId, $instanceDomain)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation zITADELWebKeysActivateWebKeyAsyncWithHttpInfo
     *
     * Activate a signing key for the instance
     *
     * @param  string $id (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function zITADELWebKeysActivateWebKeyAsyncWithHttpInfo($id, $instanceId = null, $instanceDomain = null)
    {
        $returnType = '\ArthurHlt\Zitadel\Model\V3alphaActivateWebKeyResponse';
        $request = $this->zITADELWebKeysActivateWebKeyRequest($id, $instanceId, $instanceDomain);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'zITADELWebKeysActivateWebKey'
     *
     * @param  string $id (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function zITADELWebKeysActivateWebKeyRequest($id, $instanceId = null, $instanceDomain = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling zITADELWebKeysActivateWebKey'
            );
        }

        $resourcePath = '/resources/v3alpha/web_keys/{id}/_activate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;

        // query params
        if (is_array($instanceId)) {
            $instanceId = ObjectSerializer::serializeCollection($instanceId, '', true);
        }
        if ($instanceId !== null) {
            $queryParams['instance.id'] = $instanceId;
        }
        // query params
        if (is_array($instanceDomain)) {
            $instanceDomain = ObjectSerializer::serializeCollection($instanceDomain, '', true);
        }
        if ($instanceDomain !== null) {
            $queryParams['instance.domain'] = $instanceDomain;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/grpc', 'application/grpc-web+proto'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('POST', $uri, $headers, $httpBody);
    }

    /**
     * Operation zITADELWebKeysCreateWebKey
     *
     * Generate a web key pair for the instance
     *
     * @param  \ArthurHlt\Zitadel\Model\V3alphaWebKey $key key (required)
     * @param  string $instanceId instanceId (optional)
     * @param  string $instanceDomain instanceDomain (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ArthurHlt\Zitadel\Model\V3alphaCreateWebKeyResponse|\ArthurHlt\Zitadel\Model\RpcStatus
     */
    public function zITADELWebKeysCreateWebKey($key, $instanceId = null, $instanceDomain = null)
    {
        list($response) = $this->zITADELWebKeysCreateWebKeyWithHttpInfo($key, $instanceId, $instanceDomain);
        return $response;
    }

    /**
     * Operation zITADELWebKeysCreateWebKeyWithHttpInfo
     *
     * Generate a web key pair for the instance
     *
     * @param  \ArthurHlt\Zitadel\Model\V3alphaWebKey $key (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ArthurHlt\Zitadel\Model\V3alphaCreateWebKeyResponse|\ArthurHlt\Zitadel\Model\RpcStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function zITADELWebKeysCreateWebKeyWithHttpInfo($key, $instanceId = null, $instanceDomain = null)
    {
        $request = $this->zITADELWebKeysCreateWebKeyRequest($key, $instanceId, $instanceDomain);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();

            switch($statusCode) {
                case 200:
                    if ('\ArthurHlt\Zitadel\Model\V3alphaCreateWebKeyResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\V3alphaCreateWebKeyResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ArthurHlt\Zitadel\Model\RpcStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\RpcStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ArthurHlt\Zitadel\Model\V3alphaCreateWebKeyResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\V3alphaCreateWebKeyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\RpcStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation zITADELWebKeysCreateWebKeyAsync
     *
     * Generate a web key pair for the instance
     *
     * @param  \ArthurHlt\Zitadel\Model\V3alphaWebKey $key (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function zITADELWebKeysCreateWebKeyAsync($key, $instanceId = null, $instanceDomain = null)
    {
        return $this->zITADELWebKeysCreateWebKeyAsyncWithHttpInfo($key, $instanceId, $instanceDomain)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation zITADELWebKeysCreateWebKeyAsyncWithHttpInfo
     *
     * Generate a web key pair for the instance
     *
     * @param  \ArthurHlt\Zitadel\Model\V3alphaWebKey $key (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function zITADELWebKeysCreateWebKeyAsyncWithHttpInfo($key, $instanceId = null, $instanceDomain = null)
    {
        $returnType = '\ArthurHlt\Zitadel\Model\V3alphaCreateWebKeyResponse';
        $request = $this->zITADELWebKeysCreateWebKeyRequest($key, $instanceId, $instanceDomain);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'zITADELWebKeysCreateWebKey'
     *
     * @param  \ArthurHlt\Zitadel\Model\V3alphaWebKey $key (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function zITADELWebKeysCreateWebKeyRequest($key, $instanceId = null, $instanceDomain = null)
    {
        // verify the required parameter 'key' is set
        if ($key === null || (is_array($key) && count($key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $key when calling zITADELWebKeysCreateWebKey'
            );
        }

        $resourcePath = '/resources/v3alpha/web_keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;

        // query params
        if (is_array($instanceId)) {
            $instanceId = ObjectSerializer::serializeCollection($instanceId, '', true);
        }
        if ($instanceId !== null) {
            $queryParams['instance.id'] = $instanceId;
        }
        // query params
        if (is_array($instanceDomain)) {
            $instanceDomain = ObjectSerializer::serializeCollection($instanceDomain, '', true);
        }
        if ($instanceDomain !== null) {
            $queryParams['instance.domain'] = $instanceDomain;
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/grpc', 'application/grpc-web+proto'],
            'application/jsonapplication/grpcapplication/grpc-web+proto',
            $multipart
        );

        // for model (json/xml)
        if (isset($key)) {
            if ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($key));
            } else {
                $httpBody = $key;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('POST', $uri, $headers, $httpBody);
    }

    /**
     * Operation zITADELWebKeysDeleteWebKey
     *
     * Delete a web key pair for the instance
     *
     * @param  string $id id (required)
     * @param  string $instanceId instanceId (optional)
     * @param  string $instanceDomain instanceDomain (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ArthurHlt\Zitadel\Model\V3alphaDeleteWebKeyResponse|\ArthurHlt\Zitadel\Model\RpcStatus
     */
    public function zITADELWebKeysDeleteWebKey($id, $instanceId = null, $instanceDomain = null)
    {
        list($response) = $this->zITADELWebKeysDeleteWebKeyWithHttpInfo($id, $instanceId, $instanceDomain);
        return $response;
    }

    /**
     * Operation zITADELWebKeysDeleteWebKeyWithHttpInfo
     *
     * Delete a web key pair for the instance
     *
     * @param  string $id (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ArthurHlt\Zitadel\Model\V3alphaDeleteWebKeyResponse|\ArthurHlt\Zitadel\Model\RpcStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function zITADELWebKeysDeleteWebKeyWithHttpInfo($id, $instanceId = null, $instanceDomain = null)
    {
        $request = $this->zITADELWebKeysDeleteWebKeyRequest($id, $instanceId, $instanceDomain);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();

            switch($statusCode) {
                case 200:
                    if ('\ArthurHlt\Zitadel\Model\V3alphaDeleteWebKeyResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\V3alphaDeleteWebKeyResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ArthurHlt\Zitadel\Model\RpcStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\RpcStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ArthurHlt\Zitadel\Model\V3alphaDeleteWebKeyResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\V3alphaDeleteWebKeyResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\RpcStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation zITADELWebKeysDeleteWebKeyAsync
     *
     * Delete a web key pair for the instance
     *
     * @param  string $id (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function zITADELWebKeysDeleteWebKeyAsync($id, $instanceId = null, $instanceDomain = null)
    {
        return $this->zITADELWebKeysDeleteWebKeyAsyncWithHttpInfo($id, $instanceId, $instanceDomain)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation zITADELWebKeysDeleteWebKeyAsyncWithHttpInfo
     *
     * Delete a web key pair for the instance
     *
     * @param  string $id (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function zITADELWebKeysDeleteWebKeyAsyncWithHttpInfo($id, $instanceId = null, $instanceDomain = null)
    {
        $returnType = '\ArthurHlt\Zitadel\Model\V3alphaDeleteWebKeyResponse';
        $request = $this->zITADELWebKeysDeleteWebKeyRequest($id, $instanceId, $instanceDomain);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'zITADELWebKeysDeleteWebKey'
     *
     * @param  string $id (required)
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function zITADELWebKeysDeleteWebKeyRequest($id, $instanceId = null, $instanceDomain = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling zITADELWebKeysDeleteWebKey'
            );
        }

        $resourcePath = '/resources/v3alpha/web_keys/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;

        // query params
        if (is_array($instanceId)) {
            $instanceId = ObjectSerializer::serializeCollection($instanceId, '', true);
        }
        if ($instanceId !== null) {
            $queryParams['instance.id'] = $instanceId;
        }
        // query params
        if (is_array($instanceDomain)) {
            $instanceDomain = ObjectSerializer::serializeCollection($instanceDomain, '', true);
        }
        if ($instanceDomain !== null) {
            $queryParams['instance.domain'] = $instanceDomain;
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/grpc', 'application/grpc-web+proto'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('DELETE', $uri, $headers, $httpBody);
    }

    /**
     * Operation zITADELWebKeysListWebKeys
     *
     * List web key details for the instance
     *
     * @param  string $instanceId instanceId (optional)
     * @param  string $instanceDomain instanceDomain (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ArthurHlt\Zitadel\Model\V3alphaListWebKeysResponse|\ArthurHlt\Zitadel\Model\RpcStatus
     */
    public function zITADELWebKeysListWebKeys($instanceId = null, $instanceDomain = null)
    {
        list($response) = $this->zITADELWebKeysListWebKeysWithHttpInfo($instanceId, $instanceDomain);
        return $response;
    }

    /**
     * Operation zITADELWebKeysListWebKeysWithHttpInfo
     *
     * List web key details for the instance
     *
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ArthurHlt\Zitadel\Model\V3alphaListWebKeysResponse|\ArthurHlt\Zitadel\Model\RpcStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function zITADELWebKeysListWebKeysWithHttpInfo($instanceId = null, $instanceDomain = null)
    {
        $request = $this->zITADELWebKeysListWebKeysRequest($instanceId, $instanceDomain);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();

            switch($statusCode) {
                case 200:
                    if ('\ArthurHlt\Zitadel\Model\V3alphaListWebKeysResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\V3alphaListWebKeysResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ArthurHlt\Zitadel\Model\RpcStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\RpcStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ArthurHlt\Zitadel\Model\V3alphaListWebKeysResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\V3alphaListWebKeysResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\RpcStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation zITADELWebKeysListWebKeysAsync
     *
     * List web key details for the instance
     *
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function zITADELWebKeysListWebKeysAsync($instanceId = null, $instanceDomain = null)
    {
        return $this->zITADELWebKeysListWebKeysAsyncWithHttpInfo($instanceId, $instanceDomain)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation zITADELWebKeysListWebKeysAsyncWithHttpInfo
     *
     * List web key details for the instance
     *
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function zITADELWebKeysListWebKeysAsyncWithHttpInfo($instanceId = null, $instanceDomain = null)
    {
        $returnType = '\ArthurHlt\Zitadel\Model\V3alphaListWebKeysResponse';
        $request = $this->zITADELWebKeysListWebKeysRequest($instanceId, $instanceDomain);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'zITADELWebKeysListWebKeys'
     *
     * @param  string $instanceId (optional)
     * @param  string $instanceDomain (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function zITADELWebKeysListWebKeysRequest($instanceId = null, $instanceDomain = null)
    {

        $resourcePath = '/resources/v3alpha/web_keys';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;

        // query params
        if (is_array($instanceId)) {
            $instanceId = ObjectSerializer::serializeCollection($instanceId, '', true);
        }
        if ($instanceId !== null) {
            $queryParams['instance.id'] = $instanceId;
        }
        // query params
        if (is_array($instanceDomain)) {
            $instanceDomain = ObjectSerializer::serializeCollection($instanceDomain, '', true);
        }
        if ($instanceDomain !== null) {
            $queryParams['instance.domain'] = $instanceDomain;
        }




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/grpc', 'application/grpc-web+proto'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('GET', $uri, $headers, $httpBody);
    }


    /**
     * @param string $method
     * @param string|UriInterface $uri
     * @param array $headers
     * @param string|StreamInterface|null $body
     *
     * @return RequestInterface
     */
    protected function createRequest(string $method, $uri, array $headers = [], $body = null): RequestInterface
    {
        if ($this->requestFactory instanceof RequestFactory) {
            return $this->requestFactory->createRequest(
                $method,
                $uri,
                $headers,
                $body
            );
        }

        if (is_string($body) && '' !== $body && null === $this->streamFactory) {
            throw new \RuntimeException('Cannot create request: A stream factory is required to create a request with a non-empty string body.');
        }

        $request = $this->requestFactory->createRequest($method, $uri);

        foreach ($headers as $key => $value) {
            $request = $request->withHeader($key, $value);
        }

        if (null !== $body && '' !== $body) {
            $request = $request->withBody(
                is_string($body) ? $this->streamFactory->createStream($body) : $body
            );
        }

        return $request;
    }

    private function createUri(
        string $operationHost,
        string $resourcePath,
        array $queryParams
    ): UriInterface {
        $parsedUrl = parse_url($operationHost);

        $host = $parsedUrl['host'] ?? null;
        $scheme = $parsedUrl['scheme'] ?? null;
        $basePath = $parsedUrl['path'] ?? null;
        $port = $parsedUrl['port'] ?? null;
        $user = $parsedUrl['user'] ?? null;
        $password = $parsedUrl['pass'] ?? null;

        $uri = $this->uriFactory->createUri($basePath . $resourcePath)
            ->withHost($host)
            ->withScheme($scheme)
            ->withPort($port)
            ->withQuery(ObjectSerializer::buildQuery($queryParams));

        if ($user) {
            $uri = $uri->withUserInfo($user, $password);
        }

        return $uri;
    }
}
