<?php
/**
 * FailedEventsApi
 * PHP version 7.2
 *
 * @category Class
 * @package  ArthurHlt\Zitadel
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Management API
 *
 * The management API is as the name states the interface where systems can mutate IAM objects like organizations, projects, clients, users and so on if they have the necessary access rights.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: hi@zitadel.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ArthurHlt\Zitadel\Api;

use GuzzleHttp\Psr7\MultipartStream;
use Http\Client\Common\Plugin\ErrorPlugin;
use Http\Client\Common\Plugin\RedirectPlugin;
use Http\Client\Common\PluginClient;
use Http\Client\Common\PluginClientFactory;
use Http\Client\Exception\HttpException;
use Http\Client\HttpAsyncClient;
use Http\Discovery\HttpAsyncClientDiscovery;
use Http\Discovery\Psr17FactoryDiscovery;
use Http\Discovery\Psr18ClientDiscovery;
use Http\Message\RequestFactory;
use Http\Promise\Promise;
use ArthurHlt\Zitadel\ApiException;
use ArthurHlt\Zitadel\Configuration;
use ArthurHlt\Zitadel\DebugPlugin;
use ArthurHlt\Zitadel\HeaderSelector;
use ArthurHlt\Zitadel\ObjectSerializer;
use Psr\Http\Client\ClientExceptionInterface;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestFactoryInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\StreamFactoryInterface;
use Psr\Http\Message\UriFactoryInterface;
use Psr\Http\Message\UriInterface;
use function sprintf;

/**
 * FailedEventsApi Class Doc Comment
 *
 * @category Class
 * @package  ArthurHlt\Zitadel
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FailedEventsApi
{
    /**
     * @var PluginClient
     */
    protected $httpClient;

    /**
     * @var PluginClient
     */
    protected $httpAsyncClient;

    /**
     * @var UriFactoryInterface
     */
    protected $uriFactory;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @var RequestFactoryInterface
     */
    protected $requestFactory;

    /**
     * @var StreamFactoryInterface
     */
    protected $streamFactory;

    public function __construct(
        ?ClientInterface $httpClient = null,
        ?Configuration $config = null,
        ?HttpAsyncClient $httpAsyncClient = null,
        ?UriFactoryInterface $uriFactory = null,
        ?RequestFactoryInterface $requestFactory = null,
        ?StreamFactoryInterface $streamFactory = null,
        ?HeaderSelector $selector = null,
        ?array $plugins = null,
        $hostIndex = 0
    ) {
        $this->config = $config ?? (new Configuration())->setHost('https://zitadel.cloud/management/v1');
        $this->requestFactory = $requestFactory ?? Psr17FactoryDiscovery::findRequestFactory();
        $this->streamFactory = $streamFactory ?? Psr17FactoryDiscovery::findStreamFactory();

        $plugins = $plugins ?? [
            new RedirectPlugin(['strict' => true]),
            new ErrorPlugin(),
        ];

        if ($this->config->getDebug()) {
            $plugins[] = new DebugPlugin(fopen($this->config->getDebugFile(), 'ab'));
        }

        $this->httpClient = (new PluginClientFactory())->createClient(
            $httpClient ?? Psr18ClientDiscovery::find(),
            $plugins
        );

        $this->httpAsyncClient = (new PluginClientFactory())->createClient(
            $httpAsyncClient ?? HttpAsyncClientDiscovery::find(),
            $plugins
        );

        $this->uriFactory = $uriFactory ?? Psr17FactoryDiscovery::findUriFactory();

        $this->headerSelector = $selector ?? new HeaderSelector();

        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation adminServiceRemoveFailedEvent
     *
     * Remove Failed Events
     *
     * @param  string $database database (required)
     * @param  string $viewName viewName (required)
     * @param  string $failedSequence failedSequence (required)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\ArthurHlt\Zitadel\Model\RpcStatus|\ArthurHlt\Zitadel\Model\RpcStatus
     */
    public function adminServiceRemoveFailedEvent($database, $viewName, $failedSequence)
    {
        list($response) = $this->adminServiceRemoveFailedEventWithHttpInfo($database, $viewName, $failedSequence);
        return $response;
    }

    /**
     * Operation adminServiceRemoveFailedEventWithHttpInfo
     *
     * Remove Failed Events
     *
     * @param  string $database (required)
     * @param  string $viewName (required)
     * @param  string $failedSequence (required)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\ArthurHlt\Zitadel\Model\RpcStatus|\ArthurHlt\Zitadel\Model\RpcStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function adminServiceRemoveFailedEventWithHttpInfo($database, $viewName, $failedSequence)
    {
        $request = $this->adminServiceRemoveFailedEventRequest($database, $viewName, $failedSequence);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\ArthurHlt\Zitadel\Model\RpcStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\RpcStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ArthurHlt\Zitadel\Model\RpcStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\RpcStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\RpcStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\RpcStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation adminServiceRemoveFailedEventAsync
     *
     * Remove Failed Events
     *
     * @param  string $database (required)
     * @param  string $viewName (required)
     * @param  string $failedSequence (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function adminServiceRemoveFailedEventAsync($database, $viewName, $failedSequence)
    {
        return $this->adminServiceRemoveFailedEventAsyncWithHttpInfo($database, $viewName, $failedSequence)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation adminServiceRemoveFailedEventAsyncWithHttpInfo
     *
     * Remove Failed Events
     *
     * @param  string $database (required)
     * @param  string $viewName (required)
     * @param  string $failedSequence (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function adminServiceRemoveFailedEventAsyncWithHttpInfo($database, $viewName, $failedSequence)
    {
        $returnType = 'object';
        $request = $this->adminServiceRemoveFailedEventRequest($database, $viewName, $failedSequence);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'adminServiceRemoveFailedEvent'
     *
     * @param  string $database (required)
     * @param  string $viewName (required)
     * @param  string $failedSequence (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function adminServiceRemoveFailedEventRequest($database, $viewName, $failedSequence)
    {
        // verify the required parameter 'database' is set
        if ($database === null || (is_array($database) && count($database) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $database when calling adminServiceRemoveFailedEvent'
            );
        }
        // verify the required parameter 'viewName' is set
        if ($viewName === null || (is_array($viewName) && count($viewName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $viewName when calling adminServiceRemoveFailedEvent'
            );
        }
        // verify the required parameter 'failedSequence' is set
        if ($failedSequence === null || (is_array($failedSequence) && count($failedSequence) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $failedSequence when calling adminServiceRemoveFailedEvent'
            );
        }

        $resourcePath = '/failedevents/{database}/{viewName}/{failedSequence}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;



        // path params
        if ($database !== null) {
            $resourcePath = str_replace(
                '{' . 'database' . '}',
                ObjectSerializer::toPathValue($database),
                $resourcePath
            );
        }
        // path params
        if ($viewName !== null) {
            $resourcePath = str_replace(
                '{' . 'viewName' . '}',
                ObjectSerializer::toPathValue($viewName),
                $resourcePath
            );
        }
        // path params
        if ($failedSequence !== null) {
            $resourcePath = str_replace(
                '{' . 'failedSequence' . '}',
                ObjectSerializer::toPathValue($failedSequence),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/grpc', 'application/grpc-web+proto'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('DELETE', $uri, $headers, $httpBody);
    }

    /**
     * Operation systemServiceListFailedEvents
     *
     * Returns event descriptions which cannot be processed. It&#39;s possible that some events need some retries. For example if the SMTP-API wasn&#39;t able to send an email at the first time
     *
     * @param  object $body body (required)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ArthurHlt\Zitadel\Model\Zitadelsystemv1ListFailedEventsResponse|\ArthurHlt\Zitadel\Model\RpcStatus
     */
    public function systemServiceListFailedEvents($body)
    {
        list($response) = $this->systemServiceListFailedEventsWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation systemServiceListFailedEventsWithHttpInfo
     *
     * Returns event descriptions which cannot be processed. It&#39;s possible that some events need some retries. For example if the SMTP-API wasn&#39;t able to send an email at the first time
     *
     * @param  object $body (required)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ArthurHlt\Zitadel\Model\Zitadelsystemv1ListFailedEventsResponse|\ArthurHlt\Zitadel\Model\RpcStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function systemServiceListFailedEventsWithHttpInfo($body)
    {
        $request = $this->systemServiceListFailedEventsRequest($body);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();

            switch($statusCode) {
                case 200:
                    if ('\ArthurHlt\Zitadel\Model\Zitadelsystemv1ListFailedEventsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\Zitadelsystemv1ListFailedEventsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ArthurHlt\Zitadel\Model\RpcStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\RpcStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ArthurHlt\Zitadel\Model\Zitadelsystemv1ListFailedEventsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\Zitadelsystemv1ListFailedEventsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\RpcStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation systemServiceListFailedEventsAsync
     *
     * Returns event descriptions which cannot be processed. It&#39;s possible that some events need some retries. For example if the SMTP-API wasn&#39;t able to send an email at the first time
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function systemServiceListFailedEventsAsync($body)
    {
        return $this->systemServiceListFailedEventsAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation systemServiceListFailedEventsAsyncWithHttpInfo
     *
     * Returns event descriptions which cannot be processed. It&#39;s possible that some events need some retries. For example if the SMTP-API wasn&#39;t able to send an email at the first time
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function systemServiceListFailedEventsAsyncWithHttpInfo($body)
    {
        $returnType = '\ArthurHlt\Zitadel\Model\Zitadelsystemv1ListFailedEventsResponse';
        $request = $this->systemServiceListFailedEventsRequest($body);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'systemServiceListFailedEvents'
     *
     * @param  object $body (required)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function systemServiceListFailedEventsRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling systemServiceListFailedEvents'
            );
        }

        $resourcePath = '/failedevents/_search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/grpc', 'application/grpc-web+proto'],
            'application/jsonapplication/grpcapplication/grpc-web+proto',
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('POST', $uri, $headers, $httpBody);
    }

    /**
     * Operation systemServiceRemoveFailedEvent
     *
     * Deletes the event from failed events view. the event is not removed from the change stream This call is usefull if the system was able to process the event later. e.g. if the second try of sending an email was successful. the first try produced a failed event. You can find out if it worked on the &#x60;failure_count&#x60;
     *
     * @param  string $database1 database1 (required)
     * @param  string $viewName viewName (required)
     * @param  string $failedSequence failedSequence (required)
     * @param  string $instanceId instanceId (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\ArthurHlt\Zitadel\Model\RpcStatus|\ArthurHlt\Zitadel\Model\RpcStatus
     */
    public function systemServiceRemoveFailedEvent($database1, $viewName, $failedSequence, $instanceId = null)
    {
        list($response) = $this->systemServiceRemoveFailedEventWithHttpInfo($database1, $viewName, $failedSequence, $instanceId);
        return $response;
    }

    /**
     * Operation systemServiceRemoveFailedEventWithHttpInfo
     *
     * Deletes the event from failed events view. the event is not removed from the change stream This call is usefull if the system was able to process the event later. e.g. if the second try of sending an email was successful. the first try produced a failed event. You can find out if it worked on the &#x60;failure_count&#x60;
     *
     * @param  string $database1 (required)
     * @param  string $viewName (required)
     * @param  string $failedSequence (required)
     * @param  string $instanceId (optional)
     *
     * @throws \ArthurHlt\Zitadel\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\ArthurHlt\Zitadel\Model\RpcStatus|\ArthurHlt\Zitadel\Model\RpcStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function systemServiceRemoveFailedEventWithHttpInfo($database1, $viewName, $failedSequence, $instanceId = null)
    {
        $request = $this->systemServiceRemoveFailedEventRequest($database1, $viewName, $failedSequence, $instanceId);

        try {
            try {
                $response = $this->httpClient->sendRequest($request);
            } catch (HttpException $e) {
                $response = $e->getResponse();
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $response->getStatusCode(),
                        (string) $request->getUri()
                    ),
                    $request,
                    $response,
                    $e
                );
            } catch (ClientExceptionInterface $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $request,
                    null,
                    $e
                );
            }

            $statusCode = $response->getStatusCode();

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\ArthurHlt\Zitadel\Model\RpcStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\RpcStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\ArthurHlt\Zitadel\Model\RpcStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ArthurHlt\Zitadel\Model\RpcStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\RpcStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ArthurHlt\Zitadel\Model\RpcStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation systemServiceRemoveFailedEventAsync
     *
     * Deletes the event from failed events view. the event is not removed from the change stream This call is usefull if the system was able to process the event later. e.g. if the second try of sending an email was successful. the first try produced a failed event. You can find out if it worked on the &#x60;failure_count&#x60;
     *
     * @param  string $database1 (required)
     * @param  string $viewName (required)
     * @param  string $failedSequence (required)
     * @param  string $instanceId (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function systemServiceRemoveFailedEventAsync($database1, $viewName, $failedSequence, $instanceId = null)
    {
        return $this->systemServiceRemoveFailedEventAsyncWithHttpInfo($database1, $viewName, $failedSequence, $instanceId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation systemServiceRemoveFailedEventAsyncWithHttpInfo
     *
     * Deletes the event from failed events view. the event is not removed from the change stream This call is usefull if the system was able to process the event later. e.g. if the second try of sending an email was successful. the first try produced a failed event. You can find out if it worked on the &#x60;failure_count&#x60;
     *
     * @param  string $database1 (required)
     * @param  string $viewName (required)
     * @param  string $failedSequence (required)
     * @param  string $instanceId (optional)
     *
     * @throws \InvalidArgumentException
     * @return Promise
     */
    public function systemServiceRemoveFailedEventAsyncWithHttpInfo($database1, $viewName, $failedSequence, $instanceId = null)
    {
        $returnType = 'object';
        $request = $this->systemServiceRemoveFailedEventRequest($database1, $viewName, $failedSequence, $instanceId);

        return $this->httpAsyncClient->sendAsyncRequest($request)
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function (HttpException $exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $exception->getRequest(),
                        $exception->getResponse(),
                        $exception
                    );
                }
            );
    }

    /**
     * Create request for operation 'systemServiceRemoveFailedEvent'
     *
     * @param  string $database1 (required)
     * @param  string $viewName (required)
     * @param  string $failedSequence (required)
     * @param  string $instanceId (optional)
     *
     * @throws \InvalidArgumentException
     * @return RequestInterface
     */
    public function systemServiceRemoveFailedEventRequest($database1, $viewName, $failedSequence, $instanceId = null)
    {
        // verify the required parameter 'database1' is set
        if ($database1 === null || (is_array($database1) && count($database1) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $database1 when calling systemServiceRemoveFailedEvent'
            );
        }
        // verify the required parameter 'viewName' is set
        if ($viewName === null || (is_array($viewName) && count($viewName) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $viewName when calling systemServiceRemoveFailedEvent'
            );
        }
        // verify the required parameter 'failedSequence' is set
        if ($failedSequence === null || (is_array($failedSequence) && count($failedSequence) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $failedSequence when calling systemServiceRemoveFailedEvent'
            );
        }

        $resourcePath = '/failedevents/{database_1}/{viewName}/{failedSequence}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = null;
        $multipart = false;

        // query params
        if (is_array($instanceId)) {
            $instanceId = ObjectSerializer::serializeCollection($instanceId, '', true);
        }
        if ($instanceId !== null) {
            $queryParams['instanceId'] = $instanceId;
        }


        // path params
        if ($database1 !== null) {
            $resourcePath = str_replace(
                '{' . 'database_1' . '}',
                ObjectSerializer::toPathValue($database1),
                $resourcePath
            );
        }
        // path params
        if ($viewName !== null) {
            $resourcePath = str_replace(
                '{' . 'viewName' . '}',
                ObjectSerializer::toPathValue($viewName),
                $resourcePath
            );
        }
        // path params
        if ($failedSequence !== null) {
            $resourcePath = str_replace(
                '{' . 'failedSequence' . '}',
                ObjectSerializer::toPathValue($failedSequence),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/grpc', 'application/grpc-web+proto'],
            '',
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($this->headerSelector->isJsonMime($headers['Content-Type'])) {
                $httpBody = json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();

        $uri = $this->createUri($operationHost, $resourcePath, $queryParams);

        return $this->createRequest('DELETE', $uri, $headers, $httpBody);
    }


    /**
     * @param string $method
     * @param string|UriInterface $uri
     * @param array $headers
     * @param string|StreamInterface|null $body
     *
     * @return RequestInterface
     */
    protected function createRequest(string $method, $uri, array $headers = [], $body = null): RequestInterface
    {
        if ($this->requestFactory instanceof RequestFactory) {
            return $this->requestFactory->createRequest(
                $method,
                $uri,
                $headers,
                $body
            );
        }

        if (is_string($body) && '' !== $body && null === $this->streamFactory) {
            throw new \RuntimeException('Cannot create request: A stream factory is required to create a request with a non-empty string body.');
        }

        $request = $this->requestFactory->createRequest($method, $uri);

        foreach ($headers as $key => $value) {
            $request = $request->withHeader($key, $value);
        }

        if (null !== $body && '' !== $body) {
            $request = $request->withBody(
                is_string($body) ? $this->streamFactory->createStream($body) : $body
            );
        }

        return $request;
    }

    private function createUri(
        string $operationHost,
        string $resourcePath,
        array $queryParams
    ): UriInterface {
        $parsedUrl = parse_url($operationHost);

        $host = $parsedUrl['host'] ?? null;
        $scheme = $parsedUrl['scheme'] ?? null;
        $basePath = $parsedUrl['path'] ?? null;
        $port = $parsedUrl['port'] ?? null;
        $user = $parsedUrl['user'] ?? null;
        $password = $parsedUrl['pass'] ?? null;

        $uri = $this->uriFactory->createUri($basePath . $resourcePath)
            ->withHost($host)
            ->withScheme($scheme)
            ->withPort($port)
            ->withQuery(ObjectSerializer::buildQuery($queryParams));

        if ($user) {
            $uri = $uri->withUserInfo($user, $password);
        }

        return $uri;
    }
}
